---
import {getAllTopics, getAllItems} from "../sanity/api";

const topics = await getAllTopics();
const items = await getAllItems();

interface Topic {
  _id: string;
  title: string;
  slug:
    | {
        current: string;
      }
    | string;
  backgroundColor: {
    hex: string;
  };
}

interface Item {
  _id: string;
  _type: "projects" | "articles" | "codepen";
  title: string;
  slug:
    | {
        current: string;
      }
    | string;
  topic: Topic;
  gridSpan: string;
}

// Function to get a default color if topic or backgroundColor is missing
function getBackgroundColor(item: Item): string {
  return item.topic?.backgroundColor?.hex || "#CCCCCC"; // Default to a light gray if no color is specified
}

// Function to get the topic slug, or 'uncategorized' if no topic
function getItemSlug(item: Item): string {
  if (typeof item.slug === "string") {
    return item.slug;
  } else if (typeof item.slug === "object" && item.slug?.current) {
    return item.slug.current;
  } else {
    return item._id;
  }
}

// Function to get the topic title, or 'Uncategorized' if no topic
function getTopicTitle(item: Item): string {
  return item.topic?.title || "Uncategorized";
}

// Log items for debugging
console.log("Items:", items);
---

<seciton class="grid lg:grid-cols-7 lg:pl-12 col-span-9 gap-5">
  <div class="lg:col-span-7 py-6">
    <nav
      class="flex flex-row flex-wrap gap-4 lg:gap-12 lg:text-2xl font-medium lg:py-6 items-center"
    >
      <button
        class="filter-link active opacity-100 relative pb-2 after:block after:h-1"
        data-filter="all">All</button
      >
      {
        topics.map((topic: Topic) => (
          <button
            class="filter-link opacity-100 relative pb-2 after:block after:h-1"
            data-filter={topic.slug}
          >
            {topic.title}
          </button>
        ))
      }
    </nav>
  </div>
</seciton>
<section class="tiles-container grid grid-cols-1 lg:grid-cols-3 gap-6 lg:px-12">
  {
    items.map((item: Item, index: number) => (
      <div
        class={`tile ${item.gridSpan || "lg:col-span-1"} col-span-3`}
        data-category={
          typeof item.topic?.slug === "string"
            ? item.topic.slug
            : item.topic?.slug?.current
        }
        data-order={index}
      >
        <a
          href={`/${item._type}/${getItemSlug(item)}/`}
          class="rounded-2xl drop-shadow-md min-w-full min-h-[400px] p-4 block"
          style={`background-color: ${getBackgroundColor(item)};`}
          aria-label={item.title}
        >
          <h2 class="text-xl font-bold mb-2">{item.title}</h2>
          <p class="text-sm">Type: {item._type}</p>
          <p class="text-sm">
            Topic:
            {typeof item.topic?.slug === "string"
              ? item.topic.slug
              : item.topic?.slug?.current}
          </p>
        </a>
      </div>
    ))
  }
</section>

<style>
  .tiles-container {
    perspective: 1000px;
  }

  .tile {
    opacity: 0; /* Start with tiles invisible */
    transform: rotateY(
      -90deg
    ); /* Changed to negative value for right rotation */
    transition:
      transform 0.6s ease-in-out,
      opacity 0.6s ease-in-out;
    transform-style: preserve-3d;
    backface-visibility: hidden;
    transform-origin: center center; /* Ensure rotation is centered */
  }

  .tile.visible {
    opacity: 1;
    transform: rotateY(0deg);
  }

  .filter-link {
    transition:
      opacity 0.3s,
      transform 0.3s;
  }

  .filter-link:not(.active) {
    opacity: 0.6;
  }

  .filter-link:not(.active):hover {
    opacity: 1;
    transform: translateY(-2px);
  }

  .filter-link.active {
    @apply after:absolute after:bg-secondary after:w-full after:bottom-0;
  }
</style>

<script>
  // Define types for our HTML elements
  type FilterLink = HTMLButtonElement;
  type Tile = HTMLDivElement;

  // Helper function to ensure an element is not null
  function assertNonNull<T>(value: T | null): asserts value is T {
    if (value === null) {
      throw new Error("Value is null");
    }
  }

  // Function to animate tiles on initial load
  function animateInitialLoad(tiles: NodeListOf<Tile>) {
    tiles.forEach((tile: Tile, index: number) => {
      setTimeout(() => {
        tile.classList.add("visible");
      }, index * 110); // Increased delay between tiles
    });
  }

  // Function to animate tiles after sorting
  function animateAfterSort(tiles: Tile[]) {
    tiles.forEach((tile: Tile, index: number) => {
      tile.classList.remove("visible");
      tile.offsetHeight; // Force reflow
      setTimeout(() => {
        tile.classList.add("visible");
      }, index * 110); // Increased delay between tiles
    });
  }

  // Function to initialize sorting and filtering
  function initSortAndFilter() {
    const filterLinks: NodeListOf<FilterLink> =
      document.querySelectorAll(".filter-link");
    const tiles: NodeListOf<Tile> = document.querySelectorAll(".tile");

    // Animate tiles on initial load
    setTimeout(() => {
      animateInitialLoad(tiles);
    }, 150); // Added delay before starting initial animation

    filterLinks.forEach((link: FilterLink) => {
      link.addEventListener("click", function (e: Event) {
        e.preventDefault();
        const filterValue: string | null = this.getAttribute("data-filter");
        assertNonNull(filterValue);

        // Update active state of filter links
        filterLinks.forEach((link: FilterLink) => {
          link.classList.remove("active", "opacity-100");
          link.classList.add("opacity-60");
        });
        this.classList.add("active", "opacity-100");
        this.classList.remove("opacity-60");

        // Fade out all tiles
        tiles.forEach((tile: Tile) => {
          tile.classList.remove("visible");
        });

        // Wait for fade-out, then filter and animate
        setTimeout(() => {
          const visibleTiles: Tile[] = Array.from(tiles).filter(
            (tile: Tile) => {
              const tileFilter: string | null =
                tile.getAttribute("data-category");
              assertNonNull(tileFilter);
              const isVisible =
                filterValue === "all" || tileFilter === filterValue;
              tile.style.display = isVisible ? "" : "none";
              return isVisible;
            }
          );

          // Sort visible tiles
          visibleTiles.sort((a: Tile, b: Tile) => {
            const orderA: string | null = a.getAttribute("data-order");
            const orderB: string | null = b.getAttribute("data-order");
            assertNonNull(orderA);
            assertNonNull(orderB);
            return parseInt(orderA) - parseInt(orderB);
          });

          // Reorder tiles in the DOM
          const container: HTMLElement | null = tiles[0]
            .parentNode as HTMLElement;
          assertNonNull(container);
          visibleTiles.forEach((tile: Tile) => container.appendChild(tile));

          // Animate visible tiles
          setTimeout(() => {
            animateAfterSort(visibleTiles);
          }, 50); // Added delay before starting after-sort animation
        }, 300); // Increased wait time for fade-out to complete
      });
    });
  }

  // Call the initialization function when the DOM is fully loaded
  document.addEventListener("astro:page-load", initSortAndFilter);
</script>
