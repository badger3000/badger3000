---
import {getAllTopics, getAllItems} from "../sanity/api";
import {Image} from "astro:assets";
import {urlForImage} from "../sanity/urlForImage";

const topics = await getAllTopics();
const items = await getAllItems();

interface Topic {
  _id: string;
  title: string;
  slug:
    | {
        current: string;
      }
    | string;
  backgroundColor: {
    hex: string;
  };
}

interface Item {
  _id: string;
  excerpt: string;
  _type: "projects" | "articles" | "codepen";
  title: string;
  image: any; // Changed from main_image to image
  slug: string;
  topic: Topic;
  gridSpan: string;
}
---

<seciton class="grid lg:grid-cols-7 col-span-9 gap-5">
  <div class="lg:col-span-7 py-6">
    <nav
      class="flex flex-row flex-wrap gap-4 lg:gap-12 lg:text-2xl font-medium lg:py-6 items-center"
    >
      <button
        class="filter-link active opacity-100 relative pb-2 after:block after:h-1"
        data-filter="all">All</button
      >
      {
        topics.map((topic: Topic) => (
          <button
            class="filter-link opacity-100 relative pb-2 after:block after:h-1"
            data-filter={topic.slug}
          >
            {topic.title}
          </button>
        ))
      }
    </nav>
  </div>
</seciton>
<section class="tiles-container grid grid-cols-1 lg:grid-cols-3 gap-6">
  {
    items.map((item: Item, index: number) => (
      <div
        transition:name={`${item.title}-title`}
        style={`background-color: ${item.topic?.backgroundColor.hex};`}
        class={`tile rounded-2xl  text-white drop-shadow-md min-w-full min-h-[400px] p-4 h-full ${item.gridSpan || "lg:col-span-1"} col-span-3`}
        data-category={
          typeof item.topic?.slug === "string"
            ? item.topic.slug
            : item.topic?.slug?.current
        }
        data-order={index}
      >
        <div class="w-full h-full flex flex-row items-center">
          <div class="flex flex-col w-3/4 h-full justify-between py-6">
            <h2 class="text-4xl font-bold mb-2">{item.title}</h2>
            {item.excerpt && <p class="text-lg">{item.excerpt}</p>}
            {item._type === "articles" && (
              <div class="flex">
                <a
                  href={`/${item._type}/${item.slug}/`}
                  class="rounded-full inline-block bg-white p-4 uppercase text-lg text-dark font-bold mt-6 hover:bg-dark hover:text-white transition-all duration-500 whitespace-nowrap"
                  aria-label={item.title}
                >
                  Read more
                </a>
              </div>
            )}
          </div>
          <div class="w-1/4">
            {item.image && (
              <Image
                src={urlForImage(item.image).url()}
                alt={item.title}
                inferSize={true}
              />
            )}
          </div>
        </div>
      </div>
    ))
  }
</section>

<style>
  .tiles-container {
    perspective: 1000px;
  }

  .tile {
    opacity: 0; /* Start with tiles invisible */
    transform: rotateY(
      -90deg
    ); /* Changed to negative value for right rotation */
    transition:
      transform 0.6s ease-in-out,
      opacity 0.6s ease-in-out;
    transform-style: preserve-3d;
    backface-visibility: hidden;
    transform-origin: center center; /* Ensure rotation is centered */
  }

  .tile.visible {
    opacity: 1;
    transform: rotateY(0deg);
  }

  .filter-link {
    transition:
      opacity 0.3s,
      transform 0.3s;
  }

  .filter-link:not(.active) {
    opacity: 0.6;
  }

  .filter-link:not(.active):hover {
    opacity: 1;
    transform: translateY(-2px);
  }

  .filter-link.active {
    @apply after:absolute after:bg-secondary after:w-full after:bottom-0;
  }
</style>

<script>
  // Define types for our HTML elements
  type FilterLink = HTMLButtonElement;
  type Tile = HTMLDivElement;

  // Helper function to ensure an element is not null
  function assertNonNull<T>(value: T | null): asserts value is T {
    if (value === null) {
      throw new Error("Value is null");
    }
  }

  // Function to animate tiles on initial load
  function animateInitialLoad(tiles: NodeListOf<Tile>) {
    tiles.forEach((tile: Tile, index: number) => {
      setTimeout(() => {
        tile.classList.add("visible");
      }, index * 110); // Increased delay between tiles
    });
  }

  // Function to animate tiles after sorting
  function animateAfterSort(tiles: Tile[]) {
    tiles.forEach((tile: Tile, index: number) => {
      tile.classList.remove("visible");
      tile.offsetHeight; // Force reflow
      setTimeout(() => {
        tile.classList.add("visible");
      }, index * 110); // Increased delay between tiles
    });
  }

  // Function to initialize sorting and filtering
  function initSortAndFilter() {
    const filterLinks: NodeListOf<FilterLink> =
      document.querySelectorAll(".filter-link");
    const tiles: NodeListOf<Tile> = document.querySelectorAll(".tile");

    // Animate tiles on initial load
    setTimeout(() => {
      animateInitialLoad(tiles);
    }, 150); // Added delay before starting initial animation

    filterLinks.forEach((link: FilterLink) => {
      link.addEventListener("click", function (e: Event) {
        e.preventDefault();
        const filterValue: string | null = this.getAttribute("data-filter");
        assertNonNull(filterValue);

        // Update active state of filter links
        filterLinks.forEach((link: FilterLink) => {
          link.classList.remove("active", "opacity-100");
          link.classList.add("opacity-60");
        });
        this.classList.add("active", "opacity-100");
        this.classList.remove("opacity-60");

        // Fade out all tiles
        tiles.forEach((tile: Tile) => {
          tile.classList.remove("visible");
        });

        // Wait for fade-out, then filter and animate
        setTimeout(() => {
          const visibleTiles: Tile[] = Array.from(tiles).filter(
            (tile: Tile) => {
              const tileFilter: string | null =
                tile.getAttribute("data-category");
              assertNonNull(tileFilter);
              const isVisible =
                filterValue === "all" || tileFilter === filterValue;
              tile.style.display = isVisible ? "" : "none";
              return isVisible;
            }
          );

          // Sort visible tiles
          visibleTiles.sort((a: Tile, b: Tile) => {
            const orderA: string | null = a.getAttribute("data-order");
            const orderB: string | null = b.getAttribute("data-order");
            assertNonNull(orderA);
            assertNonNull(orderB);
            return parseInt(orderA) - parseInt(orderB);
          });

          // Reorder tiles in the DOM
          const container: HTMLElement | null = tiles[0]
            .parentNode as HTMLElement;
          assertNonNull(container);
          visibleTiles.forEach((tile: Tile) => container.appendChild(tile));

          // Animate visible tiles
          setTimeout(() => {
            animateAfterSort(visibleTiles);
          }, 50); // Added delay before starting after-sort animation
        }, 300); // Increased wait time for fade-out to complete
      });
    });
  }

  // Call the initialization function when the DOM is fully loaded
  document.addEventListener("astro:page-load", initSortAndFilter);
</script>
