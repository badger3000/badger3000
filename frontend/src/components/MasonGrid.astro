<seciton class="grid lg:grid-cols-7 col-span-9 gap-5">
  <div class="lg:col-start-2 lg:col-span-4 py-6">
    <nav
      class="flex flex-row flex-wrap gap-4 lg:gap-12 lg:text-2xl font-medium lg:py-6 items-center"
    >
      <button
        class="filter-link active opacity-100 relative pb-2 after:block after:h-1 after:absolute after:bg-secondary after:w-full after:bottom-0"
        data-filter="all">All</button
      >
      <button class="filter-link opacity-100 relative pb-2" data-filter="golf"
        >Golf</button
      >
      <button
        class="filter-link opacity-60 hover:opacity-100 transition-all pb-2"
        data-filter="skateboarding">Skateboarding</button
      >
      <button
        class="filter-link opacity-60 hover:opacity-100 transition-all pb-2"
        data-filter="tech">Tech</button
      >
      <button
        class="filter-link opacity-60 hover:opacity-100 transition-all pb-2"
        data-filter="codepen">Codepen</button
      >
    </nav>
  </div>
</seciton>
<section class="tiles-container grid grid-cols-1 lg:grid-cols-3 gap-6 lg:px-32">
  <div class="tile col-span-2" data-category="golf" data-order="1">
    <a
      href="#"
      class="bg-secondary rounded-2xl drop-shadow-md min-w-full min-h-[400px] p-4 block"
    >
    </a>
  </div>
  <div class="tile col-span-1" data-category="golf" data-order="2">
    <div
      class="bg-dark rounded-2xl drop-shadow-md min-w-full min-h-[450px] p-4"
    >
    </div>
  </div>
  <div class="tile col-span-1" data-category="skateboarding" data-order="2">
    <div
      class="bg-white rounded-2xl drop-shadow-md min-w-full min-h-[300px] p-4"
    >
    </div>
  </div>
  <div class="tile col-span-1" data-category="tech" data-order="3">
    <div
      class="bg-neutral rounded-2xl drop-shadow-md min-w-full min-h-[300px] p-4"
    >
    </div>
  </div>
  <div class="tile col-span-1" data-category="codepen" data-order="4">
    <div
      class="bg-white rounded-2xl drop-shadow-md min-w-full min-h-[300px] p-4"
    >
    </div>
  </div>
</section>
<style>
  .tiles-container {
    perspective: 1000px;
  }

  .tile {
    opacity: 0; /* Start with tiles invisible */
    transform: rotateY(
      -90deg
    ); /* Changed to negative value for right rotation */
    transition:
      transform 0.6s ease-in-out,
      opacity 0.6s ease-in-out;
    transform-style: preserve-3d;
    backface-visibility: hidden;
    transform-origin: center center; /* Ensure rotation is centered */
  }

  .tile.visible {
    opacity: 1;
    transform: rotateY(0deg);
  }

  .filter-link {
    transition:
      opacity 0.3s,
      transform 0.3s;
  }

  .filter-link:not(.active) {
    opacity: 0.6;
  }

  .filter-link:not(.active):hover {
    opacity: 1;
    transform: translateY(-2px);
  }

  .filter-link.active::after {
    content: "";
    display: block;
    height: 2px;
    background-color: currentColor;
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    transform: scaleX(0);
    transition: transform 0.3s ease-in-out;
  }

  .filter-link.active::after {
    transform: scaleX(1);
  }
</style>

<script>
  // Define types for our HTML elements
  type FilterLink = HTMLButtonElement;
  type Tile = HTMLDivElement;

  // Helper function to ensure an element is not null
  function assertNonNull<T>(value: T | null): asserts value is T {
    if (value === null) {
      throw new Error("Value is null");
    }
  }

  // Function to animate tiles on initial load
  function animateInitialLoad(tiles: NodeListOf<Tile>) {
    tiles.forEach((tile: Tile, index: number) => {
      setTimeout(() => {
        tile.classList.add("visible");
      }, index * 110); // Increased delay between tiles
    });
  }

  // Function to animate tiles after sorting
  function animateAfterSort(tiles: Tile[]) {
    tiles.forEach((tile: Tile, index: number) => {
      tile.classList.remove("visible");
      tile.offsetHeight; // Force reflow
      setTimeout(() => {
        tile.classList.add("visible");
      }, index * 110); // Increased delay between tiles
    });
  }

  // Function to initialize sorting and filtering
  function initSortAndFilter() {
    const filterLinks: NodeListOf<FilterLink> =
      document.querySelectorAll(".filter-link");
    const tiles: NodeListOf<Tile> = document.querySelectorAll(".tile");

    // Animate tiles on initial load
    setTimeout(() => {
      animateInitialLoad(tiles);
    }, 150); // Added delay before starting initial animation

    filterLinks.forEach((link: FilterLink) => {
      link.addEventListener("click", function (e: Event) {
        e.preventDefault();
        const filterValue: string | null = this.getAttribute("data-filter");
        assertNonNull(filterValue);

        // Update active state of filter links
        filterLinks.forEach((link: FilterLink) => {
          link.classList.remove("active", "opacity-100");
          link.classList.add("opacity-60");
        });
        this.classList.add("active", "opacity-100");
        this.classList.remove("opacity-60");

        // Fade out all tiles
        tiles.forEach((tile: Tile) => {
          tile.classList.remove("visible");
        });

        // Wait for fade-out, then filter and animate
        setTimeout(() => {
          const visibleTiles: Tile[] = Array.from(tiles).filter(
            (tile: Tile) => {
              const tileFilter: string | null =
                tile.getAttribute("data-category");
              assertNonNull(tileFilter);
              const isVisible =
                filterValue === "all" || tileFilter === filterValue;
              tile.style.display = isVisible ? "" : "none";
              return isVisible;
            }
          );

          // Sort visible tiles
          visibleTiles.sort((a: Tile, b: Tile) => {
            const orderA: string | null = a.getAttribute("data-order");
            const orderB: string | null = b.getAttribute("data-order");
            assertNonNull(orderA);
            assertNonNull(orderB);
            return parseInt(orderA) - parseInt(orderB);
          });

          // Reorder tiles in the DOM
          const container: HTMLElement | null = tiles[0]
            .parentNode as HTMLElement;
          assertNonNull(container);
          visibleTiles.forEach((tile: Tile) => container.appendChild(tile));

          // Animate visible tiles
          setTimeout(() => {
            animateAfterSort(visibleTiles);
          }, 50); // Added delay before starting after-sort animation
        }, 300); // Increased wait time for fade-out to complete
      });
    });
  }

  // Call the initialization function when the DOM is fully loaded
  document.addEventListener("astro:page-load", initSortAndFilter);
</script>
